name: fetch-prices
on:
  schedule:
    - cron: "0 7,19 * * *"
  workflow_dispatch:

permissions:
  contents: write
  pull-requests: write

jobs:
  fetch-multi:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install deps
        run: |
          python -m pip install -U pip
          pip install -r requirements.txt

      - name: Run fetch for each profile
        env:
          CSFLOAT_API_KEY: ${{ secrets.CSFLOAT_API_KEY }}
        run: |
          for d in data/*; do
            if [ -f "$d/holdings.csv" ]; then
              echo "=== Processing $d ==="
              python fetch_prices.py "$d/holdings.csv" || true
            fi
          done

      # Normalisation robuste : garantit price_usd, détecte si price_cents est en cents ou déjà en USD.
      - name: Normalize price_history (ensure price_usd with scale detection)
        run: |
          python - <<'PY'
          import pandas as pd, numpy as np, glob

          def detect_scale(df: pd.DataFrame) -> str:
              if 'price_cents' not in df.columns:
                  return 'unknown'
              c = pd.to_numeric(df['price_cents'], errors='coerce')
              if c.dropna().empty:
                  return 'unknown'
              if 'price_usd' in df.columns:
                  u = pd.to_numeric(df['price_usd'], errors='coerce')
                  m = (u / c).replace([np.inf, -np.inf], np.nan).dropna()
                  if not m.empty:
                      med = float(median(m))
              else:
                  med = None

              # Heuristiques si pas de ratio exploitable
              frac_ratio = ((c - np.floor(c)).abs() > 1e-9).mean()
              c_max = float(c.max()) if c.notna().any() else np.nan

              # Si ratio dispo, prioritaire
              if 'price_usd' in df.columns:
                  u = pd.to_numeric(df['price_usd'], errors='coerce')
                  m = (u / c).replace([np.inf, -np.inf], np.nan).dropna()
                  if not m.empty:
                      med = float(m.median())
                      if 0.008 < med < 0.012:  # ~ 1/100
                          return 'cents'
                      if 0.8 < med < 1.2:     # ~ 1
                          return 'usd'

              # Sinon : décimales -> USD ; valeurs énormes entières -> cents
              if frac_ratio > 0.2:
                  return 'usd'
              if c_max < 1000:
                  return 'usd'
              return 'cents'

          def median(s):
              s = list(s)
              n = len(s)
              if n == 0: return float('nan')
              s.sort()
              mid = n // 2
              if n % 2 == 1:
                  return s[mid]
              return 0.5 * (s[mid - 1] + s[mid])

          changed = False
          for path in glob.glob('data/*/price_history.csv'):
              try:
                  df = pd.read_csv(path)
              except Exception as e:
                  print(f"[skip] {path}: {e}")
                  continue

              if 'ts_utc' not in df.columns or 'market_hash_name' not in df.columns:
                  print(f"[skip] {path}: missing required columns")
                  continue

              need_save = False
              if 'price_usd' not in df.columns:
                  df['price_usd'] = np.nan
                  need_save = True

              df['price_usd'] = pd.to_numeric(df['price_usd'], errors='coerce')

              if 'price_cents' in df.columns:
                  c = pd.to_numeric(df['price_cents'], errors='coerce')
                  scale = detect_scale(df)
                  if scale == 'cents':
                      target = c / 100.0
                  elif scale == 'usd':
                      target = c
                  else:
                      target = c  # fallback

                  mask = df['price_usd'].isna() | (df['price_usd'].sub(target).abs() > 0.005)
                  if mask.any():
                      df.loc[mask, 'price_usd'] = target
                      need_save = True
                      print(f"[{path}] scale={scale} | updated {int(mask.sum())} rows")

              # Optionnel : ordre de colonnes
              cols = df.columns.tolist()
              order = [c for c in ['ts_utc','market_hash_name','price_cents','price_usd'] if c in cols]
              other = [c for c in cols if c not in order]
              if order:
                  df = df[order + other]

              if need_save:
                  df.to_csv(path, index=False)
                  changed = True
                  print(f"[fixed] {path}")
              else:
                  print(f"[ok] {path} already normalized")

          open('.normalized','w').write('1' if changed else '0')
          PY

      - name: Commit & push
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git add data/*/price_history.csv
          if git diff --cached --quiet; then
            echo "No changes"
          else
            git commit -m "normalize price_history: ensure price_usd present [skip ci]"
            git push origin main
          fi
